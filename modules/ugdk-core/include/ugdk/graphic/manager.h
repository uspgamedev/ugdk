#ifndef UGDK_GRAPHIC_MANAGER_H_
#define UGDK_GRAPHIC_MANAGER_H_

#include <ugdk/structure/types.h>
#include <ugdk/math.h>

#include <ugdk/action.h>
#include <ugdk/graphic.h>
#include <ugdk/desktop.h>
#include <ugdk/util.h>

#include <ugdk/graphic/textureunit.h>

#include <string>
#include <bitset>
#include <functional>
#include <memory>
#include <unordered_set>

struct SDL_Window;
typedef void* SDL_GLContext;

namespace ugdk {
namespace graphic {

class RenderScreen;
class Renderer;
action::Scene* CreateLightrenderingScene(std::function<void (Canvas&)> render_light_function);

enum class VertexType {
    VERTEX, TEXTURE, COLOR, CUSTOM1
};

class Manager {
  public:
    Manager();
    ~Manager();
    
    bool Initialize(const std::vector<std::weak_ptr<desktop::Window>>& windows_, 
                    const math::Vector2D& canvas_size);
    void Release();

    std::weak_ptr<RenderScreen> RegisterScreen (std::weak_ptr<desktop::Window>);
    std::weak_ptr<RenderTexture>RegisterTexture(std::unique_ptr<graphic::GLTexture>&& texture);
    std::weak_ptr<RenderTexture>RegisterTexture(const math::Integer2D& size);
    /*WE NEED TO ADD A METHOD FOR RENDERTEXTURES*/

    std::weak_ptr<RenderTarget> default_target();
    const std::unordered_set<std::shared_ptr<RenderTarget>>& targets() const;

    void UnregisterTarget(const std::weak_ptr<RenderTarget>& target);

    void SetUserNearestNeighborTextures(bool enabled);

    TextureUnit ReserveTextureUnit(const graphic::GLTexture* texture = nullptr);
    void DisableVertexType(VertexType);
    unsigned int LocationForVertexType(VertexType);

    class Shaders {
      public:
        enum Flag {
            USE_LIGHT_BUFFER = 0,
            IGNORE_TEXTURE_COLOR,

            NUM_FLAGS // Value generated by the compiler
        };
    
        const ShaderProgram* current_shader() const;
        
        const ShaderProgram* GetSpecificShader(const std::bitset<NUM_FLAGS>& flags) const;

        bool IsFlagSet(Flag) const;
        void ChangeFlag(Flag, bool);

        /// Replace the ShaderProgram UGDK uses for the given combination of flags.
        /** @arg flags A STL bitset containing the flags.
            @arg program The ShaderProgram to use. This assumes you're passing the ownership of the object.
        */
        void ReplaceShader(const std::bitset<NUM_FLAGS>& flags, ShaderProgram* program);
        
        void ReplaceShader(unsigned long flags, ShaderProgram* program) {
            ReplaceShader(std::bitset<NUM_FLAGS>(flags), program);
        }

        void ReplaceShader(const std::string& flags, ShaderProgram* program) {
            ReplaceShader(std::bitset<NUM_FLAGS>(flags), program);
        }

      private:
        Shaders();
        ~Shaders();

        ShaderProgram* shaders_[1 << NUM_FLAGS];
        std::bitset<NUM_FLAGS> flags_;

        friend class Manager;
    };

    uint32_t num_targets();
    RenderTexture* light_buffer() const { return light_buffer_.get(); }

    graphic::GLTexture* white_texture() { return white_texture_; }
    Shaders& shaders() { return shaders_; }
    const Shaders& shaders() const { return shaders_; }
    ShaderProgram* light_shader() { return light_shader_; }

  private:
    void CreateLightBuffer(const math::Vector2D& size);
    void ReleaseTextureUnitID(int id);

    SDL_GLContext context_;
    std::unordered_set<std::shared_ptr<RenderTarget>> targets_;
    std::unique_ptr<RenderTexture> light_buffer_;
    std::unique_ptr<util::IDGenerator> textureunit_ids_;
    graphic::GLTexture* white_texture_;
    
    std::shared_ptr<RenderTarget> default_target_;
    Shaders shaders_;
    ShaderProgram* light_shader_;
    uint32_t active_index_;

    friend class ::ugdk::graphic::TextureUnit;
};

inline std::weak_ptr<RenderTarget> Manager::default_target() {
    return default_target_;
}

inline const std::unordered_set<std::shared_ptr<RenderTarget>>& Manager::targets() const {
    return targets_;
}

}  // namespace graphic
}  // namespace ugdk

#endif // UGDK_GRAPHIC_MANAGER_H_
